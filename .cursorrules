# General Development Rules

## Project Management
- Reference project.md for all feature implementations
- Ensure new code aligns with defined milestones
- Consider cost optimizations defined in metrics
- Maintain consistency with existing components

You should do task-based development. Git is already initialized in the project. Follow these principles ALWAYS: TDD, DRY, KISS, YAGNI. DO NOT CREATE A SEPERATE PORT TO START SERVER. Backend SERVER SHOULD ALWAYS BE STARTED at port 8000 no matter what(there will be grave consequences if you do not follow this rule).

## Retain Memory

There will be a memory file called memory.md 

The memory file will contain the state of the project, and any notes or relevant details you'd need to remember between chats.

Keep it up to date based on the project's current state. After a feature is implemented, update the memory file to reflect the current state of the project including the updated file structure. Make sure when I create a new chat you can easily know what to do based on the project.md file and the memory file and continue working from where you left off and onto the next task.

## Update Development Guidelines

Every time you choose to apply a rule(s), explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase.

Additionally, you are an expert in TypeScript, React, Vite, Python, FastAPI, Shadcn UI, Tailwind and use the latest version of all the packages you know of.

## Code Guidelines

### File Size Limit
All files must be under 200 lines of code. To achieve this:
1. **Component Decomposition**: Break large components into smaller, focused components
2. **Custom Hooks**: Extract complex logic into custom hooks
3. **Utilities**: Move reusable functions to utility files
4. **Context Providers**: Use context for complex state management
5. **Higher-Order Components**: Use HOCs for cross-cutting concerns

### Refactoring Patterns
When a file exceeds 200 lines, apply these refactoring patterns:
1. **Extract Form Sections**: For large forms, extract sections into separate components
2. **Extract Table Components**: For tables, extract headers, rows, and pagination
3. **Extract Dialog Components**: Move modal dialogs to separate files
4. **Extract Utility Functions**: Move helper functions to utility files
5. **Extract Types**: Move complex types to separate files

## Code Style and Structure
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure repository files as follows:

### Project Structure

- **Frontend**:  
  - **Directory Structure**:  
    - `frontend/src/`: Main source code  
    - `frontend/src/index.html`: Main HTML file  
    - Configuration Files:  
      - `vite.config.ts`  
      - `tsconfig.json`  
      - `tailwind.config.js`  


- **Backend**:  
  - **Directory Structure**:  
    - `backend/app/`: Main source code  
    - `backend/tests/`: Tests  
    - `document-processor/`: Document processing utilities  
    - Environment Configuration:  
      - `.env` / `.env.example`: Environment variables  

## GraphQL and Apollo Client Best Practices

```javascript
const graphqlBestPractices = [
  "Use Apollo Client for state management and data fetching",
  "Implement query components for data fetching",
  "Utilize mutations for data modifications",
  "Use fragments for reusable query parts",
  "Implement proper error handling and loading states",
];

// Folder structure
const folderStructure = `
src/
  components/
  graphql/
    queries/
    mutations/
    fragments/
  hooks/
  pages/
  utils/
`;

// Additional instructions
const additionalInstructions = `
1. Use Apollo Provider at the root of your app
2. Implement custom hooks for Apollo operations
3. Use TypeScript for type safety with GraphQL operations
4. Utilize Apollo Client's caching capabilities
5. Implement proper error boundaries for GraphQL errors
6. Use Apollo Client DevTools for debugging
7. Follow naming conventions for queries, mutations, and fragments
`;
```

## Naming Conventions
- Use lowercase with dashes for directories (e.g., components/form-wizard)
- Favor named exports for components and utilities
- Use PascalCase for component files (e.g., VisaForm.tsx)
- Use camelCase for utility files (e.g., formValidator.ts)

## TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use const objects with 'as const' assertion
- Use functional components with TypeScript interfaces
- Define strict types for message passing between different parts of the extension
- Use absolute imports for all files @/...
- Avoid try/catch blocks unless there's good reason to translate or handle error in that abstraction
- Use explicit return types for all functions

## State Management
- Use React Context for global state when needed
- Implement proper state persistence using chrome.storage (for extension)
- Implement proper cleanup in useEffect hooks

## Whenever You Need a React Component

1. Carefully consider the component's purpose, functionality, and design
2. Think slowly, step by step, and outline your reasoning
3. Check if a similar component already exists in any of the following locations
   1. packages/ui/src/components
   2. apps/spa/src/components
4. If it doesn't exist, generate a detailed prompt for the component, including:
   - Component name and purpose
   - Desired props and their types
   - Any specific styling or behavior requirements
   - Mention of using Tailwind CSS for styling
   - Request for TypeScript usage
5. URL encode the prompt.
6. Create a clickable link in this format:
   [ComponentName](https://v0.dev/chat?q={encoded_prompt})
7. After generating, adapt the component to fit our project structure:
   - Import
     - common shadcn/ui components from @repo/ui/components/ui/
     - app specific components from @/components
   - Ensure it follows our existing component patterns
   - Add any necessary custom logic or state management

## Syntax and Formatting
- Use "function" keyword for pure functions
- Avoid unnecessary curly braces in conditionals
- Use declarative JSX
- Implement proper TypeScript discriminated unions for message types

## UI and Styling
- Use Shadcn UI for components
- Use `npx shadcn@latest add <component-name>` to add new shadcn components
- Implement Tailwind CSS for styling
- Consider extension-specific constraints (popup dimensions, permissions)
- Follow Material Design guidelines for Chrome extensions
- When adding new shadcn component, document the installation command

## Performance Optimization
- SSR & Splitting: Optimize loads with SSR only when needed
- Dynamic Loading: Wrap non-critical components in Suspense
- Minimize Client Hooks: Reduce useEffect and similar hooks

## Error Handling
- Implement proper error boundaries
- Log errors appropriately for debugging
- Provide user-friendly error messages
- Handle network failures gracefully

## Testing
- Write unit tests for utilities and components
- Implement E2E tests for critical flows

## FastAPI

Write concise, technical responses with accurate Python examples. Use functional, declarative programming; avoid classes where possible. Prefer iteration and modularization over code duplication. Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission). Use lowercase with underscores for directories and files (e.g., routers/user_routes.py). Favor named exports for routes and utility functions. Use the Receive an Object, Return an Object (RORO) pattern. Use def for pure functions and async def for asynchronous operations. Use type hints for all function signatures. Prefer Pydantic models over raw dictionaries for input validation.

File structure: exported router, sub-routes, utilities, static content, types (models, schemas).

Avoid unnecessary curly braces in conditional statements. For single-line statements in conditionals, omit curly braces. Use concise, one-line syntax for simple conditional statements (e.g., if condition: do_something()).

Prioritize error handling and edge cases:

FastAPI
Pydantic v2

Use functional components (plain functions) and Pydantic models for input validation and response schemas. Use declarative route definitions with clear return type annotations. Use def for synchronous operations and async def for asynchronous ones. Minimize @app.on_event("startup") and @app.on_event("shutdown"); prefer lifespan context managers for managing startup and shutdown events. Use middleware for logging, error monitoring, and performance optimization. Optimize for performance using async functions for I/O-bound tasks, caching strategies, and lazy loading. Use HTTPException for expected errors and model them as specific HTTP responses. Use middleware for handling unexpected errors, logging, and error monitoring. Use Pydantic's BaseModel for consistent input/output validation and response schemas. Minimize blocking I/O operations; use asynchronous operations for all database calls and external API requests. Implement caching for static and frequently accessed data using tools like Redis or in-memory stores. Optimize data serialization and deserialization with Pydantic. Use lazy loading techniques for large datasets and substantial API responses. Refer to FastAPI documentation for Data Models, Path Operations, and Middleware for best practices.

```python
additional_instructions = """
1. Use type hints for all function parameters and return values
2. Implement proper input validation using Pydantic
3. Use FastAPI's background tasks for long-running operations
4. Implement proper CORS handling
5. Use FastAPI's security utilities for authentication
6. Follow PEP 8 style guide for Python code
7. Implement comprehensive unit and integration tests
"""
```

## Security
- Implement Content Security Policy
- Sanitize user inputs
- Handle sensitive data properly
- Implement proper CORS handling

Rules:
- Use lowercase for commit messages
- Keep the summary line concise
- Include description for non-obvious changes
- Reference issue numbers when applicable

## Documentation
- Maintain clear README with setup instructions
- Document API interactions and data flows
- Keep manifest.json well-documented
- Don't include comments unless it's for complex logic
- Document permission requirements
